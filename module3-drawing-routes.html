<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Flag Football Play Designer - Module 3: Drawing Routes</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }

        .app-container {
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
            padding: 30px;
            max-width: 100%;
            overflow: auto;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
        }

        .header h1 {
            color: #333;
            font-size: 2.5em;
            margin-bottom: 10px;
        }

        .header p {
            color: #666;
            font-size: 1.1em;
        }

        .field-container {
            position: relative;
            margin: 0 auto;
            border: 4px solid #2c3e50;
            border-radius: 15px;
            overflow: hidden;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
            background: #27ae60;
            width: 1920px;
            height: 1080px;
            max-width: 100%;
            max-height: 80vh;
        }

        .field {
            width: 100%;
            height: 100%;
            position: relative;
            background: 
                linear-gradient(to right, rgba(255, 255, 255, 0.1) 1px, transparent 1px),
                linear-gradient(to bottom, rgba(255, 255, 255, 0.1) 1px, transparent 1px);
            background-size: 30px 30px;
            background-position: 0 0;
        }

        /* Field markings */
        .field::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: 
                linear-gradient(to right, 
                    transparent 0%, 
                    rgba(255, 255, 255, 0.8) 0%, 
                    rgba(255, 255, 255, 0.8) 2px, 
                    transparent 2px,
                    transparent 10%,
                    rgba(255, 255, 255, 0.8) 10%, 
                    rgba(255, 255, 255, 0.8) 12px, 
                    transparent 12px,
                    transparent 20%,
                    rgba(255, 255, 255, 0.8) 20%, 
                    rgba(255, 255, 255, 0.8) 22px, 
                    transparent 22px,
                    transparent 30%,
                    rgba(255, 255, 255, 0.8) 30%, 
                    rgba(255, 255, 255, 0.8) 32px, 
                    transparent 32px,
                    transparent 40%,
                    rgba(255, 255, 255, 0.8) 40%, 
                    rgba(255, 255, 255, 0.8) 42px, 
                    transparent 42px,
                    transparent 50%,
                    rgba(255, 255, 255, 0.8) 50%, 
                    rgba(255, 255, 255, 0.8) 52px, 
                    transparent 52px,
                    transparent 60%,
                    rgba(255, 255, 255, 0.8) 60%, 
                    rgba(255, 255, 255, 0.8) 62px, 
                    transparent 62px,
                    transparent 70%,
                    rgba(255, 255, 255, 0.8) 70%, 
                    rgba(255, 255, 255, 0.8) 72px, 
                    transparent 72px,
                    transparent 80%,
                    rgba(255, 255, 255, 0.8) 80%, 
                    rgba(255, 255, 255, 0.8) 82px, 
                    transparent 82px,
                    transparent 90%,
                    rgba(255, 255, 255, 0.8) 90%, 
                    rgba(255, 255, 255, 0.8) 92px, 
                    transparent 92px,
                    transparent 100%
                ),
                linear-gradient(to right, 
                    transparent 49%, 
                    rgba(255, 255, 255, 1) 49%, 
                    rgba(255, 255, 255, 1) 51%, 
                    transparent 51%
                );
        }

        /* Drawing canvas */
        .drawing-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 5;
        }

        .drawing-canvas.drawing {
            pointer-events: all;
        }

        /* Route lines */
        .route-line {
            position: absolute;
            pointer-events: none;
            z-index: 6;
        }

        .route-line.drawing {
            pointer-events: all;
        }

        /* Toolbar */
        .toolbar {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 15px;
            padding: 15px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
            z-index: 20;
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .tool-btn {
            width: 50px;
            height: 50px;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            transition: all 0.3s ease;
            background: #ecf0f1;
            color: #2c3e50;
        }

        .tool-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 10px rgba(0, 0, 0, 0.2);
        }

        .tool-btn.active {
            background: #3498db;
            color: white;
        }

        .tool-btn.danger {
            background: #e74c3c;
            color: white;
        }

        .tool-btn.danger:hover {
            background: #c0392b;
        }

        /* Cursor styles */
        .field.drawing-cursor {
            cursor: crosshair;
        }

        .field.eraser-cursor {
            cursor: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="%23e74c3c" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M7 21h10a2 2 0 0 0 2-2V9.414a1 1 0 0 0-.293-.707l-5.414-5.414A1 1 0 0 0 12.586 3H7a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2z"></path></svg>') 12 12, auto;
        }

        /* Controls */
        .controls {
            margin-top: 20px;
            text-align: center;
        }

        .control-btn {
            background: #3498db;
            color: white;
            border: none;
            padding: 12px 24px;
            margin: 0 10px;
            border-radius: 25px;
            cursor: pointer;
            font-size: 16px;
            transition: all 0.3s ease;
        }

        .control-btn:hover {
            background: #2980b9;
            transform: translateY(-2px);
        }

        .control-btn.secondary {
            background: #95a5a6;
        }

        .control-btn.secondary:hover {
            background: #7f8c8d;
        }

        .control-btn.danger {
            background: #e74c3c;
        }

        .control-btn.danger:hover {
            background: #c0392b;
        }

        /* Info panel */
        .info-panel {
            margin-top: 20px;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 10px;
            border-left: 4px solid #3498db;
        }

        .info-panel h3 {
            color: #2c3e50;
            margin-bottom: 10px;
        }

        .info-panel p {
            color: #666;
            line-height: 1.6;
        }

        /* Responsive design */
        @media (max-width: 2000px) {
            .field-container {
                transform: scale(0.8);
                transform-origin: center;
            }
        }

        @media (max-width: 1600px) {
            .field-container {
                transform: scale(0.6);
                transform-origin: center;
            }
        }

        @media (max-width: 1200px) {
            .field-container {
                transform: scale(0.4);
                transform-origin: center;
            }
        }

        @media (max-width: 768px) {
            .app-container {
                padding: 15px;
            }
            
            .header h1 {
                font-size: 2em;
            }
            
            .field-container {
                transform: scale(0.3);
                transform-origin: center;
            }

            .toolbar {
                top: 10px;
                left: 10px;
                padding: 10px;
            }

            .tool-btn {
                width: 40px;
                height: 40px;
                font-size: 16px;
            }
        }
    </style>
</head>
<body>
    <div class="app-container">
        <div class="header">
            <h1>üèà Flag Football Play Designer</h1>
            <p>Module 3: Drawing Routes with Grid Snapping</p>
        </div>

        <div class="field-container">
            <div class="field" id="field">
                <canvas class="drawing-canvas" id="drawingCanvas"></canvas>
                <div class="toolbar">
                    <button class="tool-btn active" id="drawTool" title="Draw Routes">‚úèÔ∏è</button>
                    <button class="tool-btn" id="eraserTool" title="Eraser">üßπ</button>
                    <button class="tool-btn secondary" id="undoTool" title="Undo Last Route">‚Ü∂</button>
                    <button class="tool-btn danger" id="clearTool" title="Clear All Routes">üóëÔ∏è</button>
                </div>
            </div>
        </div>

        <div class="controls">
            <button class="control-btn" onclick="showRouteData()">Show Route Data</button>
            <button class="control-btn secondary" onclick="exportRoutes()">Export Routes</button>
            <button class="control-btn secondary" onclick="importRoutes()">Import Routes</button>
        </div>

        <div class="info-panel">
            <h3>Module 3 Features:</h3>
            <p>
                ‚úÖ Drawing tool with grid snapping<br>
                ‚úÖ Eraser tool for removing routes<br>
                ‚úÖ Undo functionality for last route<br>
                ‚úÖ Clear all routes functionality<br>
                ‚úÖ Touch and mouse support<br>
                ‚úÖ Route data storage for saving<br>
                ‚úÖ Visual feedback during drawing<br>
                ‚úÖ Responsive toolbar design
            </p>
        </div>
    </div>

    <script>
        /**
         * Module 3: Drawing Routes System
         * 
         * This module provides:
         * - Drawing routes that snap to grid
         * - Eraser tool for removing routes
         * - Undo and clear functionality
         * - Touch and mouse support
         * - Route data storage for saving
         */

        class DrawingRoutesSystem {
            constructor() {
                this.fieldWidth = 1920;
                this.fieldHeight = 1080;
                this.gridSize = 30;
                this.field = document.getElementById('field');
                this.canvas = document.getElementById('drawingCanvas');
                this.ctx = this.canvas.getContext('2d');
                
                this.currentTool = 'draw';
                this.isDrawing = false;
                this.currentPath = [];
                this.routes = [];
                this.undoStack = [];
                
                this.setupCanvas();
                this.setupEventListeners();
                this.setupToolbar();
            }

            /**
             * Setup the drawing canvas
             */
            setupCanvas() {
                this.canvas.width = this.fieldWidth;
                this.canvas.height = this.fieldHeight;
                this.ctx.lineWidth = 4;
                this.ctx.lineCap = 'round';
                this.ctx.lineJoin = 'round';
                this.ctx.strokeStyle = '#e74c3c';
                
                console.log('Drawing Routes System initialized');
            }

            /**
             * Setup event listeners for drawing
             */
            setupEventListeners() {
                // Mouse events
                this.canvas.addEventListener('mousedown', this.handleMouseDown.bind(this));
                this.canvas.addEventListener('mousemove', this.handleMouseMove.bind(this));
                this.canvas.addEventListener('mouseup', this.handleMouseUp.bind(this));
                this.canvas.addEventListener('mouseleave', this.handleMouseUp.bind(this));

                // Touch events
                this.canvas.addEventListener('touchstart', this.handleTouchStart.bind(this), { passive: false });
                this.canvas.addEventListener('touchmove', this.handleTouchMove.bind(this), { passive: false });
                this.canvas.addEventListener('touchend', this.handleTouchEnd.bind(this));
                this.canvas.addEventListener('touchcancel', this.handleTouchEnd.bind(this));

                // Prevent context menu on canvas
                this.canvas.addEventListener('contextmenu', (e) => e.preventDefault());
            }

            /**
             * Setup toolbar event listeners
             */
            setupToolbar() {
                document.getElementById('drawTool').addEventListener('click', () => this.setTool('draw'));
                document.getElementById('eraserTool').addEventListener('click', () => this.setTool('eraser'));
                document.getElementById('undoTool').addEventListener('click', () => this.undoLastRoute());
                document.getElementById('clearTool').addEventListener('click', () => this.clearAllRoutes());
            }

            /**
             * Set the current drawing tool
             * @param {string} tool - Tool name ('draw', 'eraser')
             */
            setTool(tool) {
                this.currentTool = tool;
                
                // Update toolbar UI
                document.querySelectorAll('.tool-btn').forEach(btn => btn.classList.remove('active'));
                document.getElementById(tool + 'Tool').classList.add('active');
                
                // Update cursor
                this.field.classList.remove('drawing-cursor', 'eraser-cursor');
                if (tool === 'draw') {
                    this.field.classList.add('drawing-cursor');
                } else if (tool === 'eraser') {
                    this.field.classList.add('eraser-cursor');
                }
                
                console.log('Tool changed to:', tool);
            }

            /**
             * Snap coordinates to grid
             * @param {number} x - X coordinate
             * @param {number} y - Y coordinate
             * @returns {Object} - Snapped coordinates
             */
            snapToGrid(x, y) {
                const snappedX = Math.round(x / this.gridSize) * this.gridSize;
                const snappedY = Math.round(y / this.gridSize) * this.gridSize;
                
                const clampedX = Math.max(0, Math.min(snappedX, this.fieldWidth));
                const clampedY = Math.max(0, Math.min(snappedY, this.fieldHeight));
                
                return { x: clampedX, y: clampedY };
            }

            /**
             * Handle mouse down event
             * @param {MouseEvent} e - Mouse event
             */
            handleMouseDown(e) {
                e.preventDefault();
                this.startDrawing(e.clientX, e.clientY);
            }

            /**
             * Handle mouse move event
             * @param {MouseEvent} e - Mouse event
             */
            handleMouseMove(e) {
                if (!this.isDrawing) return;
                
                e.preventDefault();
                this.updateDrawing(e.clientX, e.clientY);
            }

            /**
             * Handle mouse up event
             * @param {MouseEvent} e - Mouse event
             */
            handleMouseUp(e) {
                if (!this.isDrawing) return;
                
                e.preventDefault();
                this.endDrawing();
            }

            /**
             * Handle touch start event
             * @param {TouchEvent} e - Touch event
             */
            handleTouchStart(e) {
                e.preventDefault();
                const touch = e.touches[0];
                this.startDrawing(touch.clientX, touch.clientY);
            }

            /**
             * Handle touch move event
             * @param {TouchEvent} e - Touch event
             */
            handleTouchMove(e) {
                if (!this.isDrawing) return;
                
                e.preventDefault();
                const touch = e.touches[0];
                this.updateDrawing(touch.clientX, touch.clientY);
            }

            /**
             * Handle touch end event
             * @param {TouchEvent} e - Touch event
             */
            handleTouchEnd(e) {
                if (!this.isDrawing) return;
                
                e.preventDefault();
                this.endDrawing();
            }

            /**
             * Start drawing
             * @param {number} clientX - Client X coordinate
             * @param {number} clientY - Client Y coordinate
             */
            startDrawing(clientX, clientY) {
                const rect = this.canvas.getBoundingClientRect();
                const x = clientX - rect.left;
                const y = clientY - rect.top;
                
                const snapped = this.snapToGrid(x, y);
                
                if (this.currentTool === 'draw') {
                    this.isDrawing = true;
                    this.currentPath = [snapped];
                    
                    // Start drawing on canvas
                    this.ctx.beginPath();
                    this.ctx.moveTo(snapped.x, snapped.y);
                } else if (this.currentTool === 'eraser') {
                    this.eraseAtPoint(snapped.x, snapped.y);
                }
            }

            /**
             * Update drawing
             * @param {number} clientX - Client X coordinate
             * @param {number} clientY - Client Y coordinate
             */
            updateDrawing(clientX, clientY) {
                if (!this.isDrawing) return;
                
                const rect = this.canvas.getBoundingClientRect();
                const x = clientX - rect.left;
                const y = clientY - rect.top;
                
                const snapped = this.snapToGrid(x, y);
                
                if (this.currentTool === 'draw') {
                    // Only add point if it's different from the last point
                    const lastPoint = this.currentPath[this.currentPath.length - 1];
                    if (!lastPoint || lastPoint.x !== snapped.x || lastPoint.y !== snapped.y) {
                        this.currentPath.push(snapped);
                        
                        // Draw line to new point
                        this.ctx.lineTo(snapped.x, snapped.y);
                        this.ctx.stroke();
                    }
                } else if (this.currentTool === 'eraser') {
                    this.eraseAtPoint(snapped.x, snapped.y);
                }
            }

            /**
             * End drawing
             */
            endDrawing() {
                if (!this.isDrawing) return;
                
                this.isDrawing = false;
                
                if (this.currentTool === 'draw' && this.currentPath.length > 1) {
                    // Save the route
                    this.saveRoute(this.currentPath);
                }
                
                this.currentPath = [];
            }

            /**
             * Save a route to the routes array
             * @param {Array} path - Array of points
             */
            saveRoute(path) {
                const route = {
                    id: Date.now(),
                    path: [...path],
                    color: this.ctx.strokeStyle,
                    width: this.ctx.lineWidth
                };
                
                this.routes.push(route);
                console.log('Route saved:', route);
            }

            /**
             * Erase at a specific point
             * @param {number} x - X coordinate
             * @param {number} y - Y coordinate
             */
            eraseAtPoint(x, y) {
                const eraserRadius = 20;
                
                // Find routes that intersect with the eraser
                const routesToRemove = [];
                
                this.routes.forEach((route, index) => {
                    for (let i = 0; i < route.path.length - 1; i++) {
                        const point1 = route.path[i];
                        const point2 = route.path[i + 1];
                        
                        // Check if eraser point is close to the line segment
                        const distance = this.distanceToLineSegment(x, y, point1.x, point1.y, point2.x, point2.y);
                        
                        if (distance < eraserRadius) {
                            routesToRemove.push(index);
                            break;
                        }
                    }
                });
                
                // Remove routes (in reverse order to maintain indices)
                routesToRemove.reverse().forEach(index => {
                    this.routes.splice(index, 1);
                });
                
                if (routesToRemove.length > 0) {
                    this.redrawAllRoutes();
                }
            }

            /**
             * Calculate distance from point to line segment
             * @param {number} px - Point X
             * @param {number} py - Point Y
             * @param {number} x1 - Line start X
             * @param {number} y1 - Line start Y
             * @param {number} x2 - Line end X
             * @param {number} y2 - Line end Y
             * @returns {number} - Distance
             */
            distanceToLineSegment(px, py, x1, y1, x2, y2) {
                const A = px - x1;
                const B = py - y1;
                const C = x2 - x1;
                const D = y2 - y1;
                
                const dot = A * C + B * D;
                const lenSq = C * C + D * D;
                
                if (lenSq === 0) return Math.sqrt(A * A + B * B);
                
                let param = dot / lenSq;
                
                let xx, yy;
                
                if (param < 0) {
                    xx = x1;
                    yy = y1;
                } else if (param > 1) {
                    xx = x2;
                    yy = y2;
                } else {
                    xx = x1 + param * C;
                    yy = y1 + param * D;
                }
                
                const dx = px - xx;
                const dy = py - yy;
                return Math.sqrt(dx * dx + dy * dy);
            }

            /**
             * Redraw all routes on the canvas
             */
            redrawAllRoutes() {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                
                this.routes.forEach(route => {
                    this.ctx.strokeStyle = route.color;
                    this.ctx.lineWidth = route.width;
                    this.ctx.beginPath();
                    
                    if (route.path.length > 0) {
                        this.ctx.moveTo(route.path[0].x, route.path[0].y);
                        
                        for (let i = 1; i < route.path.length; i++) {
                            this.ctx.lineTo(route.path[i].x, route.path[i].y);
                        }
                        
                        this.ctx.stroke();
                    }
                });
                
                // Reset to default style
                this.ctx.strokeStyle = '#e74c3c';
                this.ctx.lineWidth = 4;
            }

            /**
             * Undo the last route
             */
            undoLastRoute() {
                if (this.routes.length === 0) {
                    console.log('No routes to undo');
                    return;
                }
                
                // Save to undo stack
                this.undoStack.push(this.routes.pop());
                
                // Redraw canvas
                this.redrawAllRoutes();
                
                console.log('Route undone');
            }

            /**
             * Clear all routes
             */
            clearAllRoutes() {
                if (this.routes.length === 0) {
                    console.log('No routes to clear');
                    return;
                }
                
                if (confirm('Are you sure you want to clear all routes?')) {
                    // Save to undo stack
                    this.undoStack.push([...this.routes]);
                    
                    this.routes = [];
                    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                    
                    console.log('All routes cleared');
                }
            }

            /**
             * Get all route data
             * @returns {Array} - Array of route objects
             */
            getRouteData() {
                return [...this.routes];
            }

            /**
             * Set route data
             * @param {Array} routes - Array of route objects
             */
            setRouteData(routes) {
                this.routes = [...routes];
                this.redrawAllRoutes();
            }

            /**
             * Export routes as JSON
             * @returns {string} - JSON string
             */
            exportRoutes() {
                return JSON.stringify(this.routes, null, 2);
            }

            /**
             * Import routes from JSON
             * @param {string} jsonString - JSON string
             */
            importRoutes(jsonString) {
                try {
                    const routes = JSON.parse(jsonString);
                    this.setRouteData(routes);
                    console.log('Routes imported successfully');
                } catch (error) {
                    console.error('Error importing routes:', error);
                    alert('Error importing routes. Please check the JSON format.');
                }
            }
        }

        // Initialize the drawing routes system
        const drawingSystem = new DrawingRoutesSystem();

        // Global functions for controls
        function showRouteData() {
            const routes = drawingSystem.getRouteData();
            console.log('Current route data:', routes);
            
            let message = `Current Routes: ${routes.length}\n\n`;
            routes.forEach((route, index) => {
                message += `Route ${index + 1}: ${route.path.length} points\n`;
            });
            
            alert(message);
        }

        function exportRoutes() {
            const jsonData = drawingSystem.exportRoutes();
            const blob = new Blob([jsonData], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            
            const a = document.createElement('a');
            a.href = url;
            a.download = 'routes.json';
            a.click();
            
            URL.revokeObjectURL(url);
        }

        function importRoutes() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.json';
            
            input.onchange = (e) => {
                const file = e.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        drawingSystem.importRoutes(e.target.result);
                    };
                    reader.readAsText(file);
                }
            };
            
            input.click();
        }

        // Export for use by other modules
        window.DrawingRoutesSystem = DrawingRoutesSystem;
        window.drawingSystem = drawingSystem;
    </script>
</body>
</html>