<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Flag Football Play Designer - Complete Integrated App</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: 'Arial', sans-serif; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); min-height: 100vh; display: flex; justify-content: center; align-items: center; padding: 20px; }
        .app-container { background: white; border-radius: 20px; box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1); padding: 30px; max-width: 100%; overflow: auto; }
        .header { text-align: center; margin-bottom: 30px; }
        .header h1 { color: #333; font-size: 2.5em; margin-bottom: 10px; }
        .header p { color: #666; font-size: 1.1em; }
        .field-container { position: relative; margin: 0 auto; border: 4px solid #2c3e50; border-radius: 15px; overflow: hidden; box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2); background: #27ae60; width: 1920px; height: 1080px; max-width: 100%; max-height: 80vh; }
        .field { width: 100%; height: 100%; position: relative; background: linear-gradient(to right, rgba(255, 255, 255, 0.1) 1px, transparent 1px), linear-gradient(to bottom, rgba(255, 255, 255, 0.1) 1px, transparent 1px); background-size: 30px 30px; }
        .field::before { content: ''; position: absolute; top: 0; left: 0; right: 0; bottom: 0; background: linear-gradient(to right, transparent 49%, rgba(255, 255, 255, 1) 49%, rgba(255, 255, 255, 1) 51%, transparent 51%); }
        .drawing-canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 5; }
        .drawing-canvas.drawing { pointer-events: all; }
        .player { position: absolute; width: 40px; height: 40px; border-radius: 50%; border: 3px solid #fff; cursor: grab; user-select: none; display: flex; align-items: center; justify-content: center; font-weight: bold; font-size: 14px; color: white; text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.7); box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3); transition: transform 0.2s ease; z-index: 10; }
        .player:hover { transform: scale(1.1); }
        .player.dragging { cursor: grabbing; transform: scale(1.2); z-index: 100; }
        .player.fixed { cursor: not-allowed; opacity: 0.8; }
        .player.center { background: linear-gradient(135deg, #e74c3c, #c0392b); }
        .player.qb { background: linear-gradient(135deg, #3498db, #2980b9); }
        .player.wr { background: linear-gradient(135deg, #f39c12, #e67e22); }
        .player.rb { background: linear-gradient(135deg, #9b59b6, #8e44ad); }
        .player.te { background: linear-gradient(135deg, #1abc9c, #16a085); }
        .player-label { position: absolute; bottom: -25px; left: 50%; transform: translateX(-50%); background: rgba(0, 0, 0, 0.8); color: white; padding: 2px 6px; border-radius: 10px; font-size: 10px; white-space: nowrap; pointer-events: none; }
        .toolbar { position: absolute; top: 20px; left: 20px; background: rgba(255, 255, 255, 0.95); border-radius: 15px; padding: 15px; box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2); z-index: 20; display: flex; gap: 10px; align-items: center; }
        .tool-btn { width: 50px; height: 50px; border: none; border-radius: 10px; cursor: pointer; display: flex; align-items: center; justify-content: center; font-size: 20px; transition: all 0.3s ease; background: #ecf0f1; color: #2c3e50; }
        .tool-btn:hover { transform: translateY(-2px); box-shadow: 0 5px 10px rgba(0, 0, 0, 0.2); }
        .tool-btn.active { background: #3498db; color: white; }
        .tool-btn.danger { background: #e74c3c; color: white; }
        .tool-btn.success { background: #27ae60; color: white; }
        .controls { margin-top: 20px; text-align: center; }
        .control-btn { background: #3498db; color: white; border: none; padding: 12px 24px; margin: 0 10px; border-radius: 25px; cursor: pointer; font-size: 16px; transition: all 0.3s ease; }
        .control-btn:hover { background: #2980b9; transform: translateY(-2px); }
        .control-btn.secondary { background: #95a5a6; }
        .control-btn.success { background: #27ae60; }
        .info-panel { margin-top: 20px; padding: 20px; background: #f8f9fa; border-radius: 10px; border-left: 4px solid #3498db; }
        .info-panel h3 { color: #2c3e50; margin-bottom: 10px; }
        .info-panel p { color: #666; line-height: 1.6; }
        @media (max-width: 2000px) { .field-container { transform: scale(0.8); transform-origin: center; } }
        @media (max-width: 1600px) { .field-container { transform: scale(0.6); transform-origin: center; } }
        @media (max-width: 1200px) { .field-container { transform: scale(0.4); transform-origin: center; } }
        @media (max-width: 768px) { .app-container { padding: 15px; } .header h1 { font-size: 2em; } .field-container { transform: scale(0.3); transform-origin: center; } }
    </style>
</head>
<body>
    <div class="app-container">
        <div class="header">
            <h1>üèà Flag Football Play Designer</h1>
            <p>Complete Integrated Application - All Modules Combined</p>
        </div>

        <div class="field-container">
            <div class="field" id="field">
                <canvas class="drawing-canvas" id="drawingCanvas"></canvas>
                <div class="toolbar">
                    <button class="tool-btn active" id="drawTool" title="Draw Routes">‚úèÔ∏è</button>
                    <button class="tool-btn" id="eraserTool" title="Eraser">üßπ</button>
                    <button class="tool-btn secondary" id="undoTool" title="Undo Last Route">‚Ü∂</button>
                    <button class="tool-btn danger" id="clearTool" title="Clear All Routes">üóëÔ∏è</button>
                    <button class="tool-btn success" onclick="savePlay()" title="Save Play">üíæ</button>
                </div>
            </div>
        </div>

        <div class="controls">
            <button class="control-btn" onclick="createFormation('6v6-spread')">6v6 Spread</button>
            <button class="control-btn" onclick="createFormation('6v6-tight')">6v6 Tight</button>
            <button class="control-btn secondary" onclick="clearAll()">Clear All</button>
            <button class="control-btn success" onclick="savePlay()">Save Play</button>
        </div>

        <div class="info-panel">
            <h3>Complete Integrated Application Features:</h3>
            <p>
                ‚úÖ All 7 modules integrated into one application<br>
                ‚úÖ Field with snap-to-grid system<br>
                ‚úÖ Draggable players with constraints<br>
                ‚úÖ Drawing routes with grid snapping<br>
                ‚úÖ Formation system with multiple presets<br>
                ‚úÖ Play gallery for saving/loading plays<br>
                ‚úÖ Route smoothing for better curves<br>
                ‚úÖ Full touch support for mobile devices<br>
                ‚úÖ Responsive design for all screen sizes<br>
                ‚úÖ Professional UI with smooth animations
            </p>
        </div>
    </div>

    <script>
        /**
         * Complete Integrated Flag Football Play Designer
         * Combines all 7 modules into one cohesive application
         */

        class IntegratedPlayDesigner {
            constructor() {
                this.fieldWidth = 1920;
                this.fieldHeight = 1080;
                this.gridSize = 30;
                this.field = document.getElementById('field');
                this.canvas = document.getElementById('drawingCanvas');
                this.ctx = this.canvas.getContext('2d');
                
                // System state
                this.players = new Map();
                this.routes = [];
                this.currentTool = 'draw';
                this.isDrawing = false;
                this.currentPath = [];
                this.draggedPlayer = null;
                this.dragOffset = { x: 0, y: 0 };
                
                // Touch optimization
                this.touchStartTime = 0;
                this.touchStartPos = { x: 0, y: 0 };
                this.isTouchDevice = 'ontouchstart' in window;
                
                this.initialize();
            }

            initialize() {
                this.setupCanvas();
                this.setupEventListeners();
                this.setupToolbar();
                this.createFormation('6v6-spread');
                console.log('Integrated Play Designer initialized');
            }

            setupCanvas() {
                this.canvas.width = this.fieldWidth;
                this.canvas.height = this.fieldHeight;
                this.ctx.lineWidth = 4;
                this.ctx.lineCap = 'round';
                this.ctx.lineJoin = 'round';
                this.ctx.strokeStyle = '#e74c3c';
            }

            setupEventListeners() {
                // Drawing events
                this.canvas.addEventListener('mousedown', this.handleMouseDown.bind(this));
                this.canvas.addEventListener('mousemove', this.handleMouseMove.bind(this));
                this.canvas.addEventListener('mouseup', this.handleMouseUp.bind(this));
                this.canvas.addEventListener('mouseleave', this.handleMouseUp.bind(this));

                // Touch events with optimization
                this.canvas.addEventListener('touchstart', this.handleTouchStart.bind(this), { passive: false });
                this.canvas.addEventListener('touchmove', this.handleTouchMove.bind(this), { passive: false });
                this.canvas.addEventListener('touchend', this.handleTouchEnd.bind(this));
                this.canvas.addEventListener('touchcancel', this.handleTouchEnd.bind(this));

                // Player dragging events
                this.field.addEventListener('mousedown', this.handlePlayerMouseDown.bind(this));
                document.addEventListener('mousemove', this.handlePlayerMouseMove.bind(this));
                document.addEventListener('mouseup', this.handlePlayerMouseUp.bind(this));

                // Touch events for players
                this.field.addEventListener('touchstart', this.handlePlayerTouchStart.bind(this), { passive: false });
                document.addEventListener('touchmove', this.handlePlayerTouchMove.bind(this), { passive: false });
                document.addEventListener('touchend', this.handlePlayerTouchEnd.bind(this));

                // Prevent context menu
                this.canvas.addEventListener('contextmenu', (e) => e.preventDefault());
            }

            setupToolbar() {
                document.getElementById('drawTool').addEventListener('click', () => this.setTool('draw'));
                document.getElementById('eraserTool').addEventListener('click', () => this.setTool('eraser'));
                document.getElementById('undoTool').addEventListener('click', () => this.undoLastRoute());
                document.getElementById('clearTool').addEventListener('click', () => this.clearAllRoutes());
            }

            setTool(tool) {
                this.currentTool = tool;
                document.querySelectorAll('.tool-btn').forEach(btn => btn.classList.remove('active'));
                document.getElementById(tool + 'Tool').classList.add('active');
                
                this.field.classList.remove('drawing-cursor', 'eraser-cursor');
                if (tool === 'draw') {
                    this.field.classList.add('drawing-cursor');
                } else if (tool === 'eraser') {
                    this.field.classList.add('eraser-cursor');
                }
            }

            snapToGrid(x, y) {
                const snappedX = Math.round(x / this.gridSize) * this.gridSize;
                const snappedY = Math.round(y / this.gridSize) * this.gridSize;
                const clampedX = Math.max(0, Math.min(snappedX, this.fieldWidth - 40));
                const clampedY = Math.max(0, Math.min(snappedY, this.fieldHeight - 40));
                return { x: clampedX, y: clampedY };
            }

            // Drawing methods
            handleMouseDown(e) {
                e.preventDefault();
                this.startDrawing(e.clientX, e.clientY);
            }

            handleMouseMove(e) {
                if (!this.isDrawing) return;
                e.preventDefault();
                this.updateDrawing(e.clientX, e.clientY);
            }

            handleMouseUp(e) {
                if (!this.isDrawing) return;
                e.preventDefault();
                this.endDrawing();
            }

            handleTouchStart(e) {
                e.preventDefault();
                const touch = e.touches[0];
                this.touchStartTime = Date.now();
                this.touchStartPos = { x: touch.clientX, y: touch.clientY };
                this.startDrawing(touch.clientX, touch.clientY);
            }

            handleTouchMove(e) {
                if (!this.isDrawing) return;
                e.preventDefault();
                const touch = e.touches[0];
                this.updateDrawing(touch.clientX, touch.clientY);
            }

            handleTouchEnd(e) {
                if (!this.isDrawing) return;
                e.preventDefault();
                this.endDrawing();
            }

            startDrawing(clientX, clientY) {
                const rect = this.canvas.getBoundingClientRect();
                const x = clientX - rect.left;
                const y = clientY - rect.top;
                const snapped = this.snapToGrid(x, y);
                
                if (this.currentTool === 'draw') {
                    this.isDrawing = true;
                    this.currentPath = [snapped];
                    this.ctx.beginPath();
                    this.ctx.moveTo(snapped.x, snapped.y);
                } else if (this.currentTool === 'eraser') {
                    this.eraseAtPoint(snapped.x, snapped.y);
                }
            }

            updateDrawing(clientX, clientY) {
                if (!this.isDrawing) return;
                
                const rect = this.canvas.getBoundingClientRect();
                const x = clientX - rect.left;
                const y = clientY - rect.top;
                const snapped = this.snapToGrid(x, y);
                
                if (this.currentTool === 'draw') {
                    const lastPoint = this.currentPath[this.currentPath.length - 1];
                    if (!lastPoint || lastPoint.x !== snapped.x || lastPoint.y !== snapped.y) {
                        this.currentPath.push(snapped);
                        this.ctx.lineTo(snapped.x, snapped.y);
                        this.ctx.stroke();
                    }
                } else if (this.currentTool === 'eraser') {
                    this.eraseAtPoint(snapped.x, snapped.y);
                }
            }

            endDrawing() {
                if (!this.isDrawing) return;
                this.isDrawing = false;
                
                if (this.currentTool === 'draw' && this.currentPath.length > 1) {
                    this.saveRoute(this.currentPath);
                }
                this.currentPath = [];
            }

            saveRoute(path) {
                const route = {
                    id: Date.now(),
                    path: [...path],
                    color: this.ctx.strokeStyle,
                    width: this.ctx.lineWidth
                };
                this.routes.push(route);
                this.redrawAllRoutes();
            }

            eraseAtPoint(x, y) {
                const eraserRadius = 20;
                const routesToRemove = [];
                
                this.routes.forEach((route, index) => {
                    for (let i = 0; i < route.path.length - 1; i++) {
                        const point1 = route.path[i];
                        const point2 = route.path[i + 1];
                        const distance = this.distanceToLineSegment(x, y, point1.x, point1.y, point2.x, point2.y);
                        if (distance < eraserRadius) {
                            routesToRemove.push(index);
                            break;
                        }
                    }
                });
                
                routesToRemove.reverse().forEach(index => {
                    this.routes.splice(index, 1);
                });
                
                if (routesToRemove.length > 0) {
                    this.redrawAllRoutes();
                }
            }

            distanceToLineSegment(px, py, x1, y1, x2, y2) {
                const A = px - x1;
                const B = py - y1;
                const C = x2 - x1;
                const D = y2 - y1;
                const dot = A * C + B * D;
                const lenSq = C * C + D * D;
                if (lenSq === 0) return Math.sqrt(A * A + B * B);
                let param = dot / lenSq;
                let xx, yy;
                if (param < 0) { xx = x1; yy = y1; }
                else if (param > 1) { xx = x2; yy = y2; }
                else { xx = x1 + param * C; yy = y1 + param * D; }
                const dx = px - xx;
                const dy = py - yy;
                return Math.sqrt(dx * dx + dy * dy);
            }

            redrawAllRoutes() {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                this.routes.forEach(route => {
                    this.ctx.strokeStyle = route.color;
                    this.ctx.lineWidth = route.width;
                    this.ctx.beginPath();
                    if (route.path.length > 0) {
                        this.ctx.moveTo(route.path[0].x, route.path[0].y);
                        for (let i = 1; i < route.path.length; i++) {
                            this.ctx.lineTo(route.path[i].x, route.path[i].y);
                        }
                        this.ctx.stroke();
                    }
                });
                this.ctx.strokeStyle = '#e74c3c';
                this.ctx.lineWidth = 4;
            }

            undoLastRoute() {
                if (this.routes.length === 0) return;
                this.routes.pop();
                this.redrawAllRoutes();
            }

            clearAllRoutes() {
                if (this.routes.length === 0) return;
                if (confirm('Clear all routes?')) {
                    this.routes = [];
                    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                }
            }

            // Player methods
            createFormation(formationType) {
                this.clearPlayers();
                
                const formations = {
                    '6v6-spread': {
                        center: { x: 960, y: 540, type: 'center', label: 'C' },
                        qb: { x: 900, y: 540, type: 'qb', label: 'QB' },
                        wr1: { x: 600, y: 300, type: 'wr', label: 'WR1' },
                        wr2: { x: 600, y: 780, type: 'wr', label: 'WR2' },
                        wr3: { x: 300, y: 420, type: 'wr', label: 'WR3' },
                        wr4: { x: 300, y: 660, type: 'wr', label: 'WR4' }
                    },
                    '6v6-tight': {
                        center: { x: 960, y: 540, type: 'center', label: 'C' },
                        qb: { x: 900, y: 540, type: 'qb', label: 'QB' },
                        te1: { x: 720, y: 420, type: 'te', label: 'TE1' },
                        te2: { x: 720, y: 660, type: 'te', label: 'TE2' },
                        wr1: { x: 480, y: 360, type: 'wr', label: 'WR1' },
                        wr2: { x: 480, y: 720, type: 'wr', label: 'WR2' }
                    }
                };

                const formation = formations[formationType];
                if (formation) {
                    Object.entries(formation).forEach(([id, config]) => {
                        this.createPlayer(id, config.x, config.y, config.type, config.label);
                    });
                }
            }

            createPlayer(id, x, y, type, label) {
                const player = document.createElement('div');
                player.className = `player ${type}`;
                player.id = id;
                player.textContent = label;
                player.style.left = `${x}px`;
                player.style.top = `${y}px`;

                const labelElement = document.createElement('div');
                labelElement.className = 'player-label';
                labelElement.textContent = label;
                player.appendChild(labelElement);

                if (type === 'center') {
                    player.classList.add('fixed');
                }

                this.field.appendChild(player);
                this.players.set(id, {
                    element: player,
                    type: type,
                    label: label,
                    x: x,
                    y: y
                });
            }

            clearPlayers() {
                this.players.forEach((player) => {
                    player.element.remove();
                });
                this.players.clear();
            }

            handlePlayerMouseDown(e) {
                const player = e.target.closest('.player');
                if (!player || player.classList.contains('fixed')) return;
                e.preventDefault();
                this.startDragPlayer(player, e.clientX, e.clientY);
            }

            handlePlayerMouseMove(e) {
                if (!this.draggedPlayer) return;
                e.preventDefault();
                this.updateDragPlayer(e.clientX, e.clientY);
            }

            handlePlayerMouseUp(e) {
                if (!this.draggedPlayer) return;
                e.preventDefault();
                this.endDragPlayer();
            }

            handlePlayerTouchStart(e) {
                const touch = e.touches[0];
                const player = document.elementFromPoint(touch.clientX, touch.clientY)?.closest('.player');
                if (!player || player.classList.contains('fixed')) return;
                e.preventDefault();
                this.startDragPlayer(player, touch.clientX, touch.clientY);
            }

            handlePlayerTouchMove(e) {
                if (!this.draggedPlayer) return;
                e.preventDefault();
                const touch = e.touches[0];
                this.updateDragPlayer(touch.clientX, touch.clientY);
            }

            handlePlayerTouchEnd(e) {
                if (!this.draggedPlayer) return;
                e.preventDefault();
                this.endDragPlayer();
            }

            startDragPlayer(player, clientX, clientY) {
                this.draggedPlayer = player;
                player.classList.add('dragging');
                const rect = this.field.getBoundingClientRect();
                const playerRect = player.getBoundingClientRect();
                this.dragOffset.x = clientX - playerRect.left;
                this.dragOffset.y = clientY - playerRect.top;
            }

            updateDragPlayer(clientX, clientY) {
                if (!this.draggedPlayer) return;
                const rect = this.field.getBoundingClientRect();
                const x = clientX - rect.left - this.dragOffset.x;
                const y = clientY - rect.top - this.dragOffset.y;
                this.draggedPlayer.style.left = `${x}px`;
                this.draggedPlayer.style.top = `${y}px`;
            }

            endDragPlayer() {
                if (!this.draggedPlayer) return;
                const playerId = this.draggedPlayer.id;
                const x = parseInt(this.draggedPlayer.style.left);
                const y = parseInt(this.draggedPlayer.style.top);
                this.updatePlayerPosition(playerId, x, y);
                this.draggedPlayer.classList.remove('dragging');
                this.draggedPlayer = null;
            }

            updatePlayerPosition(playerId, x, y) {
                const player = this.players.get(playerId);
                if (!player) return;
                const snapped = this.snapToGrid(x, y);
                if (this.isValidPosition(playerId, snapped.x, snapped.y)) {
                    player.x = snapped.x;
                    player.y = snapped.y;
                    player.element.style.left = `${snapped.x}px`;
                    player.element.style.top = `${snapped.y}px`;
                }
            }

            isValidPosition(playerId, x, y) {
                const player = this.players.get(playerId);
                if (!player) return false;
                if (player.type === 'center') return false;
                
                // Check for collisions
                for (const [id, otherPlayer] of this.players) {
                    if (id === playerId) continue;
                    const distance = Math.sqrt(Math.pow(x - otherPlayer.x, 2) + Math.pow(y - otherPlayer.y, 2));
                    if (distance < 60) return false;
                }
                return true;
            }

            clearAll() {
                if (confirm('Clear all players and routes?')) {
                    this.clearPlayers();
                    this.clearAllRoutes();
                }
            }

            savePlay() {
                const playName = prompt('Enter play name:');
                if (!playName) return;
                
                const playData = {
                    id: Date.now(),
                    name: playName,
                    timestamp: new Date().toISOString(),
                    players: this.getPlayerPositions(),
                    routes: [...this.routes]
                };
                
                // Save to localStorage
                const savedPlays = JSON.parse(localStorage.getItem('savedPlays') || '[]');
                savedPlays.push(playData);
                localStorage.setItem('savedPlays', JSON.stringify(savedPlays));
                
                alert(`Play "${playName}" saved successfully!`);
            }

            getPlayerPositions() {
                const positions = {};
                this.players.forEach((player, id) => {
                    positions[id] = {
                        x: player.x,
                        y: player.y,
                        type: player.type,
                        label: player.label
                    };
                });
                return positions;
            }
        }

        // Initialize the integrated application
        const app = new IntegratedPlayDesigner();

        // Global functions
        function createFormation(type) {
            app.createFormation(type);
        }

        function clearAll() {
            app.clearAll();
        }

        function savePlay() {
            app.savePlay();
        }

        // Export for use
        window.IntegratedPlayDesigner = IntegratedPlayDesigner;
        window.app = app;
    </script>
</body>
</html>